(in-package #:graph-utils)

(defun simple-test ()
  ;;(let ((graph (make-graph :directed? t)))
  (let ((graph (make-graph :directed? nil)))
    (add-node graph "node1")
    (add-node graph "node2")
    (add-node graph "node3")
    (add-node graph "node4")
    (add-edge graph "node1" "node2")
    graph))

(defun typed-test ()
  (time
   (let ((graph (make-typed-graph)))
     (dotimes (i 1000)
       (add-edge-type graph (intern (format nil "~@R" (1+ i)) :keyword)))
     (dotimes (x 2500000)
       (add-node graph (format nil "~B" x)))
     (dotimes (x 10000)
       (dotimes (y 10000)
         (unless (= x y)
           (let ((r (random 3)))
             (when (or (= 1 r) (= 0 r))
               (add-edge graph x y
                         :edge-type
                         (intern (format nil "~@R" (1+ (random 1000)))
                                 :keyword)))))))
     graph)))
#|
  (let ((graph (make-typed-graph :initial-edge-types '(:is-a :has-name))))
    (add-node graph "Person")
    (add-node graph "Human")
    (add-node graph "Kevin")
    (add-node graph "No one")
    (add-edge graph "Person" "Human" :edge-type :is-a)
    (add-edge graph "Person" "Kevin" :edge-type :has-name)
    (add-edge graph "No one" "Person" :edge-type :owns)
    (values graph
            (list-edges graph)
            (cons "Person" (neighbors graph "Person"))
            (cons "Person" (inbound-neighbors graph "Person"))
            (cons "Person" (outbound-neighbors graph "Person")))))
|#

(defun shortest-path-test ()
  (let ((graph (make-graph :directed? t)))
    (dolist (node '(:a :b :c :d :e))
      (add-node graph node))
    (loop for (start end weight) in '((:a :b 9)
                                      (:a :d 4)
                                      (:a :e 1)
                                      (:e :d 2)
                                      (:e :c 6)
                                      (:d :c 3)
                                      (:b :d 4)
                                      (:c :b 2))
          do (add-edge graph start end :weight weight))
    (assert (equal (multiple-value-list (find-shortest-path graph :a :b))
                   '(((0 1)) 1)))
    (assert (equal (multiple-value-list
                    (find-shortest-path graph :a :b :use-weights-p t))
                   '(((0 4) (4 3) (3 2) (2 1)) 8)))
    (assert (equal (multiple-value-list
                    (find-shortest-path graph :e :c))
                   '(((4 2)) 1)))
    (assert (equal (multiple-value-list
                    (find-shortest-path graph :e :c :use-weights-p t))
                   '(((4 3) (3 2)) 5)))
    (assert (or (equal (multiple-value-list
                        (find-shortest-path graph :a :c))
                       '(((0 3) (3 2)) 2))
                (equal (multiple-value-list
                        (find-shortest-path graph :a :c))
                       '(((0 4) (4 2)) 2))))
    (assert (equal (multiple-value-list
                    (find-shortest-path graph :a :c :use-weights-p t))
                   '(((0 4) (4 3) (3 2)) 6)))
    (assert (null (find-shortest-path graph :c :a)))))

(defun run-tests ()
  (let ((flow1 (parse-pajek "data/flow1.net"))
        (flow2 (parse-pajek "data/flow.net"))
        (flow-simple (parse-pajek "data/flow-simple.net"))
        (bgraph (parse-pajek "data/bipartite1.net"))
        (results nil))
    (dolist (alg '(:edmond-karp :dinic :karzanov :goldberg-tarjan))
      (let ((f (compute-maximum-flow flow-simple 0 3 :algorithm alg)))
        (dbg "graph flow-simple: ~A says max flow is ~D" alg f)
        (push (list alg :flow-simple f) results))
      (let ((f (compute-maximum-flow flow1 0 5 :algorithm alg)))
        (dbg "graph flow1: ~A says max flow is ~D" alg f)
        (push (list alg :flow1 f) results))
      (let ((f (compute-maximum-flow flow2 0 5 :algorithm alg)))
        (dbg "graph flow2: ~A says max flow is ~D" alg f)
        (push (list alg :flow2 f) results)))
    (dolist (alg '(:edmond-karp :dinic :karzanov :goldberg-tarjan))
      (multiple-value-bind (p1 p2) (bipartite? bgraph :show-partitions? t)
        (let ((matching
               (sort
                (if (every #'evenp p1)
                    (compute-maximum-matching bgraph p1 p2 :algorithm alg)
                    (compute-maximum-matching bgraph p2 p1 :algorithm alg))
                #'< :key 'first)))
          (dbg "graph bipartite1: ~A says matching is~% ~A" alg matching)
          (push (list alg :matching matching) results))))
    results))
